{
    "tiddlers": {
        "$:/plugins/sukima/talktimer/license": {
            "title": "$:/plugins/sukima/talktimer/license",
            "creator": "Sukima",
            "text": "<style>\n.plugins-sukima-talktimer-license > p {\n  text-align: justify;\n}\n.plugins-sukima-talktimer-license > p.copy {\n  text-align: left;\n}\n</style>\n<div class=\"plugins-sukima-talktimer-license\">\n\n@@.copy\nPlugin work Copyright &copy; 2020 Devin Weaver, http://tritarget.org\n@@\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n</div>\n"
        },
        "$:/plugins/sukima/talktimer/readme": {
            "title": "$:/plugins/sukima/talktimer/readme",
            "creator": "Sukima",
            "type": "text/vnd.tiddlywiki",
            "text": "A Toast Masters style timer will turn green when you've matched the goal time, yellow when you are near over time, and red when the timer is past the cutoff time.\n\nIn Toast Masters usually one person is responsible for timing a talk and will show colored cards. I found this feedback helpful during talks but also don't always have someone there to time me.\n\nThis plugin works well with my [[presentation plugin|https://sukima.github.io/tiddlywiki-reveal-js]].\n\nThis exposes a `<$talktimer/>` widget which is a button. Clicking on the button will start/pause the timer, <kbd>Alt</kbd> clicking will reset the timer to zero.\n\n```xml\n<$talktimer/>\n```\n\n!! Usage\n\nThe widget takes the following attributes which all use the same time format: `ss`, `mm:ss`, or `hh:mm:ss`.\n\n;overtime\n:When to mark the timer as overtime (red, default: `5:00`)\n;oktime\n:When to mark the timer as goal reached (green, default: overtime / 2)\n;warntime\n:When to mark the timer as warning nearing over time (yellow, default: half way between oktime and overtime)\n\n\n!! Customization\n\nIf you wish to customize the look you can add a `class` attribute and use CSS. The markup is a `button` with a `time` element as the button label. The button will have a `data-state` attribute you can use to customize each state using the `[attribute~=value]` CSS selector.\n\nBy default the button will have a `talktimer` class which comes bundled with a style already. Adding a `class` attribute will remove `talktimer` and return it to a normal tiddlywiki button.\n\nThe data-state can have any of these states separated by spaces: `running`, `paused`, `undertime`, `oktime`, `warntime`, and `overtime`.\n\nFor example if you wanted to make the button text change colors you could `<$talktimer class=\"mytimer\"/>`\n\n```css\n.mytimer[data-state~=paused] {\n  border: thin solid orange;\n}\n\n.mytimer[data-state~=running] {\n  border: thin solid black;\n}\n\n.mytimer[data-state~=undertime] {\n  color: black;\n}\n\n.mytimer[data-state~=oktime] {\n  color: green;\n}\n\n.mytimer[data-state~=warntime] {\n  color: yellow;\n}\n\n.mytimer[data-state~=overtime] {\n  color: red;\n}\n```\n"
        },
        "$:/plugins/sukima/talktimer/libs/fsm.js": {
            "title": "$:/plugins/sukima/talktimer/libs/fsm.js",
            "text": "/*\\\ntitle: $:/plugins/sukima/talktimer/libs/fsm.js\ntype: application/javascript\nmodule-type: library\n\nA micro FSM implementation\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nfunction transitionMachine(machine, { value: state = machine.initial } = {}, { type: event }) {\n  const A = i => Array.isArray(i) ? i : [i];\n  let transition = machine.states[state].on?.[event] ?? machine.on?.[event] ?? { target: state };\n  let value = transition.target ?? transition;\n  let changed = value !== state;\n  let actions = [\n    ...(changed ? A(machine.states[state].exit ?? []) : []),\n    ...A(transition.actions ?? []),\n    ...(changed ? A(machine.states[value].entry ?? []) : [])\n  ];\n  return { value, changed, actions };\n}\n\nfunction interpret(machine, actions = {}) {\n  const STOPPED = Symbol('stopped');\n  let listners = new Set();\n  let service = {\n    state: STOPPED,\n    send(evt, extra = {}) {\n      if (service.state === STOPPED) { return service; }\n      let event = { ...extra, ...(evt.type ? evt : { type: evt }) };\n      service.state = transitionMachine(machine, service.state, event);\n      service.state.actions.forEach(action => actions[action]?.(event));\n      listners.forEach(listener => listener(service.state, event));\n      return service;\n    },\n    onTransition(cb) {\n      listeners.add(cb);\n      return service;\n    },\n    start() {\n      service.state = undefined;\n      return service.send('#init');\n    },\n    stop() {\n      service.state = STOPPED;\n      listners.clear();\n    }\n  };\n  return service;\n}\n\nexports.transitionMachine = transitionMachine;\nexports.interpret = interpret;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/sukima/talktimer/libs/ticker.js": {
            "title": "$:/plugins/sukima/talktimer/libs/ticker.js",
            "text": "/*\\\ntitle: $:/plugins/sukima/talktimer/libs/ticker.js\ntype: application/javascript\nmodule-type: library\n\nA Toast Master compatible time ticker\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nconst { interpret } = require('$:/plugins/sukima/talktimer/libs/fsm.js');\n\nconst TIMER_MACHINE = {\n  initial: 'init',\n  on: {\n    RESET: { target: 'paused', actions: '_setTimeToZero' }\n  },\n  states: {\n    init: {\n      on: { START: 'paused' }\n    },\n    running: {\n      entry: ['_activateTimer', '_nextTick'],\n      on: { TOGGLE: 'paused' }\n    },\n    paused: {\n      entry: '_deactivateTimer',\n      on: { TOGGLE: 'running' }\n    }\n  }\n};\n\nconst TICKER_MACHINE = {\n  initial: 'undertime',\n  on: { RESET: 'undertime' },\n  states: {\n    undertime: { on: { OK: 'oktime' } },\n    oktime: { on: { WARN: 'warntime' } },\n    warntime: { on: { OVER: 'overtime' } },\n    overtime: {}\n  }\n};\n\nclass Ticker {\n\n  elapsedTime = 0;\n  _timerService = interpret(TIMER_MACHINE, this).start();\n  _tickerService = interpret(TICKER_MACHINE, this).start();\n\n  constructor({ oktime, warntime, overtime, onTick = () => {}}) {\n    this.overtime = overtime || 5 * 60e3;\n    this.oktime = oktime || Math.ceil(this.overtime / 2);\n    this.warntime = warntime || Math.ceil(this.oktime / 2) + this.oktime;\n    this.onTick = onTick;\n  }\n\n  get state() {\n    return [this._timerService.state.value,this._tickerService.state.value].filter(Boolean).join(' ');\n  }\n\n  start() {\n    this._sendEvent('START');\n    this._notifyOnTick();\n  }\n\n  toggle() {\n    this._sendEvent('TOGGLE');\n    this._notifyOnTick();\n  }\n\n  reset() {\n    this._sendEvent('RESET');\n    this._notifyOnTick();\n  }\n\n  destroy() {\n    this._deactivateTimer();\n    this._timerService.stop();\n    this._tickerService.stop();\n  }\n\n  _sendEvent(event) {\n    this._timerService.send(event);\n    this._tickerService.send(event);\n  }\n\n  _notifyOnTick() {\n    let { state, elapsedTime } = this;\n    this.onTick({ state, elapsedTime });\n  }\n\n  _setTimeToZero() {\n    this.elapsedTime = 0;\n  }\n\n  _activateTimer() {\n    this._timer = setInterval(() => this._nextTick(), 1000);\n  }\n\n  _deactivateTimer() {\n    clearInterval(this._timer);\n    this._lastTrackingTime = 0;\n  }\n\n  _nextTick() {\n    let { _lastTrackingTime: lastTrackingTime = 0 } = this;\n    let now = new Date().getTime();\n    this._lastTrackingTime = now;\n    if (lastTrackingTime !== 0) {\n      this.elapsedTime = this.elapsedTime + (now - lastTrackingTime);\n    }\n    if (this.elapsedTime >= this.oktime) { this._sendEvent('OK'); }\n    if (this.elapsedTime >= this.warntime) { this._sendEvent('WARN'); }\n    if (this.elapsedTime >= this.overtime) { this._sendEvent('OVER'); }\n    this._notifyOnTick();\n  }\n\n}\n\nexports.ticker = Ticker;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/sukima/talktimer/libs/time-utils.js": {
            "title": "$:/plugins/sukima/talktimer/libs/time-utils.js",
            "text": "/*\\\ntitle: $:/plugins/sukima/talktimer/libs/time-utils.js\ntype: application/javascript\nmodule-type: library\n\nSimple utils for converting time values\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nconst SECONDS = 1e3;\nconst MINUTES = 6e4;\nconst HOURS = 36e5;\n\nfunction seconds(str) {\n  return parseInt(str, 10) * SECONDS;\n}\n\nfunction minutes(str) {\n  return parseInt(str, 10) * MINUTES;\n}\n\nfunction hours(str) {\n  return parseInt(str, 10) * HOURS;\n}\n\nfunction *reduceParts(milliseconds) {\n  for (let unit of [HOURS, MINUTES, SECONDS]) {\n    let t = Math.floor(milliseconds / unit);\n    milliseconds = milliseconds - t;\n    yield t;\n  }\n}\n\nfunction pad(number = 0) {\n  return `0${number}`.slice(-2);\n}\n\nfunction tDehumanize(humanizedString = '') {\n  let parts = humanizedString.split(':');\n  switch (parts.length) {\n    case 1: return seconds(parts[0]);\n    case 2: return minutes(parts[0]) + seconds(parts[1]);\n    case 3: return hours(parts[0]) + minutes(parts[1]) + seconds(parts[2]);\n    default: return undefined;\n  }\n}\n\nfunction tHumanize(milliseconds) {\n  let [hours, minutes, seconds] = [...reduceParts(milliseconds)];\n  if (hours === 0) {\n    return `${pad(minutes)}:${pad(seconds)}`;\n  } else {\n    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;\n  }\n}\n\nfunction tISODuration(milliseconds) {\n  let parts = [...reduceParts(milliseconds)].filter(i => i > 0);\n  switch (parts.length) {\n    case 1: return `PT${parts[0]}S`;\n    case 2: return `PT${parts[0]}M${parts[1]}S`;\n    case 3: return `PT${parts[0]}H${parts[1]}M${parts[2]}S`;\n    default: return undefined;\n  }\n}\n\nexports.tDehumanize = tDehumanize;\nexports.tHumanize = tHumanize;\nexports.tISODuration = tISODuration;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/sukima/talktimer/widgets/talktimer.js": {
            "title": "$:/plugins/sukima/talktimer/widgets/talktimer.js",
            "text": "/*\\\ntitle: $:/plugins/sukima/talktimer/widgets/talktimer.js\ntype: application/javascript\nmodule-type: widget\n\nA Toast Master compatible talk timer\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nconst Widget = require('$:/core/modules/widgets/widget.js').widget;\nconst Ticker = require('$:/plugins/sukima/talktimer/libs/ticker.js').ticker;\nconst {\n  tDehumanize,\n  tHumanize,\n  tISODuration\n} = require('$:/plugins/sukima/talktimer/libs/time-utils.js');\n\nclass TalkTimer extends Widget {\n\n  render(parent, nextSibling) {\n    this.parentDomNode = parent;\n    this.computeAttributes();\n    this.execute();\n    let timerNode = this.document.createElement('BUTTON');\n    timerNode.className = this.getAttribute('class', 'talktimer');\n    timerNode.setAttribute('type', 'button');\n    timerNode.setAttribute('title', 'LeftClick to start/pause; Alt+LeftClick to reset');\n    timerNode.appendChild(this.document.createElement('TIME'));\n    parent.insertBefore(timerNode,nextSibling);\n    this.domNodes.push(timerNode);\n    timerNode.addEventListener('click', e => this._handleClick(e));\n    this._ticker.start();\n  }\n\n  execute() {\n    console.log(this.attributes);\n    this._ticker = new Ticker({\n      oktime: tDehumanize(this.attributes.oktime),\n      warntime: tDehumanize(this.attributes.warntime),\n      overtime: tDehumanize(this.attributes.overtime),\n      onTick: status => this._updateDomNode(status)\n    });\n  }\n\n  removeChildDomNodes() {\n    this._ticker.destory();\n    super.removeChildDomNodes();\n  }\n\n  _handleClick(event) {\n    if (event.altKey) {\n      this._ticker.reset();\n    } else {\n      this._ticker.toggle();\n    }\n  }\n\n  _updateDomNode({ state, elapsedTime }) {\n    let [timerNode] = this.domNodes;\n    let [timeNode] = timerNode.children;\n    timerNode.dataset.state = state;\n    timeNode.innerText = tHumanize(elapsedTime);\n    timeNode.setAttribute('datetime', tISODuration(elapsedTime));\n  }\n\n}\n\nexports.talktimer = TalkTimer;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "talktimer.css": {
            "title": "talktimer.css",
            "tags": "$:/tags/Stylesheet",
            "type": "text/css",
            "text": ".talktimer {\n  --color-shadow: #7f7f7f;\n  --color-dark-text: #000000;\n  --color-invert-text: #ffffff;\n  --color-undertime: #f4f4f4;\n  --color-oktime: #3fe491;\n  --color-warntime: #f4d02d;\n  --color-overtime: #ff0040;\n  --paused-opacity: 0.6;\n\n  border: none;\n  border-radius: 1em;\n  box-shadow: .2rem .2rem .5rem var(--color-shadow);\n  padding: 10em 4em;\n  margin: 0;\n  width: 100%;\n}\n\n.talktimer > time {\n  font-family: \"Lucida Console\", \"Monaco\", monospace;\n  font-size: 4em;\n  font-weight: 600;\n  position: relative;\n}\n\n.talktimer[data-state~=paused] {\n  opacity: var(--paused-opacity);\n}\n\n.talktimer[data-state~=paused] > time::after {\n  content: \"*\";\n  font-size: .6em;\n  position: absolute;\n  top: 0;\n}\n\n.talktimer[data-state~=running] {\n  box-shadow: .4rem .4rem .4rem var(--color-shadow);\n}\n\n.talktimer[data-state~=undertime] {\n  background-color: var(--color-undertime);\n  color: var(--color-dark-text);\n}\n\n.talktimer[data-state~=oktime] {\n  background-color: var(--color-oktime);\n  color: var(--color-invert-text);\n}\n\n.talktimer[data-state~=warntime] {\n  background-color: var(--color-warntime);\n  color: var(--color-dark-text);\n}\n\n.talktimer[data-state~=overtime] {\n  background-color: var(--color-overtime);\n  color: var(--color-invert-text);\n}\n"
        }
    }
}